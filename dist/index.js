function n(n,t,o,e){return new(o||(o=Promise))((function(i,r){function c(n){try{s(e.next(n))}catch(n){r(n)}}function u(n){try{s(e.throw(n))}catch(n){r(n)}}function s(n){var t;n.done?i(n.value):(t=n.value,t instanceof o?t:new o((function(n){n(t)}))).then(c,u)}s((e=e.apply(n,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const t=6e4,o=(n=t)=>new Promise((t=>setTimeout(t,n)));function e(t,o,e){return n(this,void 0,void 0,(function*(){const n=(n=>()=>new Promise(((t,o)=>{try{t(n())}catch(n){o(n)}})))(t);return yield i(n,o,e)}))}function i(o,e=t,i=new c("function did not complete within allowed time")){return n(this,void 0,void 0,(function*(){const n=Symbol("DELAY_EXPIRED"),t=yield Promise.race([o(),r(e,n)]);if(t===n)throw i;return t}))}const r=(t,e)=>n(void 0,void 0,void 0,(function*(){return yield o(t),e}));class c extends Error{constructor(){super(...arguments),this.isTimeout=!0}}function u(n){return!0===n.isTimeout}export{c as TimeoutError,u as isTimeoutError,o as wait,e as waitUntil,i as waitUntilAsync};
